<?xml version="1.0" encoding="UTF-8"?>
<!--

    Copyright (c) 2010, 2020 Oracle and/or its affiliates. All rights reserved.

    This program and the accompanying materials are made available under the
    terms of the Eclipse Distribution License v. 1.0, which is available at
    http://www.eclipse.org/org/documents/edl-v10.php.

    SPDX-License-Identifier: BSD-3-Clause

-->

<!DOCTYPE book [
<!ENTITY % ents SYSTEM "metro.ent">
%ents;
]>
<chapter version="5.0" xml:id="ahigx" xml:lang="en"
         xmlns="http://docbook.org/ns/docbook"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:svg="http://www.w3.org/2000/svg"
         xmlns:m="http://www.w3.org/1998/Math/MathML"
         xmlns:html="http://www.w3.org/1999/xhtml"
         xmlns:db="http://docbook.org/ns/docbook">
    <title>Data Contracts</title>

    <section xml:id="ahigy">
        <title>Web Service - Start from Java</title>

        <para>This section provides guidelines for designing an XML schema
        exported by a Java web service designed starting from Java.
        Jakarta XML Binding
        provides a rich set of annotations and types for mapping Java classes
        to different XML Schema constructs. The guidelines provide guidance on
        using Jakarta XML Binding annotations and types so that developer friendly
        bindings may be generated by XML serialization mechanisms (svcutil) on
        WCF client.</para>

        <para>Not all Jakarta XML Binding annotations are included here; not all are
        relevant from an interoperability standpoint. For example, the
        annotation <code>@XmlAccessorType</code> provides control over default
        serialization of fields and properties in a Java class but otherwise
        has no effect on the on-the-wire XML representation or the XML schema
        generated from a Java class. Select Jakarta XML Binding annotations are therefore
        not included here in the guidance.</para>

        <para>The guidance includes several examples, which use the following
        conventions:</para>

        <itemizedlist>
            <listitem>
                <para>The prefix <code>xs:</code> is used to represent XML
                Schema namespace.</para>
            </listitem>

            <listitem>
                <para>Jakarta XML Binding annotations are defined in
                <code>jakarta.xml.bind.annotation</code> package but, for
                brevity, the package name has been omitted.</para>
            </listitem>
        </itemizedlist>

        <section xml:id="ahigz">
            <title>Data Types</title>

            <para>This section covers the following topics:</para>

            <itemizedlist>
                <listitem>
                    <para><xref linkend="ahiha"
                    xrefstyle="select:title" /></para>
                </listitem>

                <listitem>
                    <para><xref linkend="ahihb"
                    xrefstyle="select:title" /></para>
                </listitem>

                <listitem>
                    <para><xref linkend="ahihc"
                    xrefstyle="select:title" /></para>
                </listitem>

                <listitem>
                    <para><xref linkend="ahihd"
                    xrefstyle="select:title" /></para>
                </listitem>

                <listitem>
                    <para><xref linkend="ahihe"
                    xrefstyle="select:title" /></para>
                </listitem>

                <listitem>
                    <para><xref linkend="ahihf"
                    xrefstyle="select:title" /></para>
                </listitem>

                <listitem>
                    <para><xref linkend="ahihg"
                    xrefstyle="select:title" /></para>
                </listitem>

                <listitem>
                    <para><xref linkend="ahihh"
                    xrefstyle="select:title" /></para>
                </listitem>

                <listitem>
                    <para><xref linkend="ahihi"
                    xrefstyle="select:title" /></para>
                </listitem>

                <listitem>
                    <para><xref linkend="ahihm"
                    xrefstyle="select:title" /></para>
                </listitem>
            </itemizedlist>

            <section xml:id="ahiha">
                <title>Primitives and Wrappers</title>

                <para><emphasis>Guideline:</emphasis> Java primitive and
                wrapper classes map to slightly different XML schema
                representations. Therefore, .NET bindings will vary
                accordingly.</para>

                <example>
                    <title>A Java primitive type and its corresponding wrapper
                        class</title>
                    <programlisting language="java" linenumbering="unnumbered">//-- Java code fragment
public class StockItem{
    public Double wholeSalePrice;
    public double retailPrice;
}

//--Schema fragment
&lt;xs:complexType name="stockItem"&gt;
    &lt;xs:sequence&gt;
        &lt;xs:element name="wholeSalePrice" type="xs:double" minOccurs="0"/&gt;
        &lt;xs:element name="retailPrice" type="xs:double"/&gt;
    &lt;/xs:sequence&gt;
&lt;/xs:complexType&gt;

//-- .NET C# auto generated code from schema
public partial class stockItem
{
    private double wholeSalePrice;
    private bool wholeSalePriceFieldSpecified;
    private double retailPrice;

    public double wholeSalePrice
    {
        get{ return this.wholeSalePrice;}
        set{this.wholeSalePrice=value}
    }

    public bool wholeSalePriceSpecified
    {
        get{ return this.wholeSalePriceFieldSpecified;}
        set{this.wholeSalePriceFieldSpecified=value}
    }

    public double retailPrice
    {
        get{ return this.retailPrice;}
        set{this.retailPrice=value}
    }
}

//-- C# code fragment
stockItem s = new stockItem();
s.wholeSalePrice = Double.parse("198.92");
s.wholeSalePriceSpecified = true;
s.retailPrice = Double.parse("300.25");</programlisting>

                </example>
            </section>

            <section xml:id="ahihb">
                <title>BigDecimal Type</title>

                <para><emphasis>Guideline:</emphasis> Limit decimal values to
                the range and precision of .NET's
                <code>System.decimal</code>.</para>

                <para><code>java.math.BigDecimal</code> maps to
                <code>xs:decimal</code>. .NET maps <code>xs:decimal</code> to
                <code>System.decimal</code>. These two data types support
                different range and precision.
                <code>java.math.BigDecimal</code> supports arbitrary
                precision. <code>System.decimal</code> does not. For
                interoperability use only values within the range and
                precision of <code>System.decimal</code>. (See
                <code>System.decimal.Minvalue</code> and
                <code>System.decimal.Maxvalue</code>.) Any values outside of
                this range require a customized .NET client.</para>

                <example>
                    <title><code>BigDecimal</code> usage</title>

                    <programlisting language="java" linenumbering="unnumbered">//--- Java code fragment
public class RetBigDecimal {
    private BigDecimal arg0;

    public BigDecimal getArg0() { return this.arg0; }
    public void setArg0(BigDecimal arg0) { this.arg0 = arg0; }
}

//--- Schema fragment
&lt;xs:complexType name="retBigDecimal"&gt;
    &lt;xs:sequence&gt;
        &lt;xs:element name="arg0" type="xs:decimal" minOccurs="0"/&gt;
    &lt;/xs:sequence&gt;
&lt;/xs:complexType&gt;

//--- .NET auto generated code from schema
public partial class retBigDecimal{
    private decimal arg0Field;
    private bool arg0FieldSpecified;

    public decimal arg0 {
        get { return this.arg0Field;}
        set { this.arg0Field = value;}
    }

    public bool arg0Specified {
        get { return this.arg0FieldSpecified;}
        set { this.arg0FieldSpecified = value;}
    }
}

//--- C# code fragment
System.CultureInfo engCulture = new System.CultureInfo("en-US");
retBigDecimal bd = new retBigDecimal();
bd.arg0 = System.decimal.MinValue;

retBigDecimal negBd = new retBigDecimal();
negBd = System.decimal.Parse("-0.0", engCulture);</programlisting>
                </example>
            </section>

            <section xml:id="ahihc">
                <title>java.net.URI Type</title>

                <para><emphasis>Guideline:</emphasis> Use the
                <code>@XmlSchemaType</code> annotation for a strongly typed
                binding to a .NET client generated with the
                <code>DataContractSerializer</code>.</para>

                <para><code>java.net.URI</code> maps to
                <code>xs:string</code>. .NET maps <code>xs:string</code> to
                <code>System.string</code>. Annotation
                <code>@XmlSchemaType</code> can be used to define a more
                strongly typed binding to a .NET client generated with the
                <code>DataContractSerializer</code>.
                <code>@XmlSchemaType</code> can be used to map
                <code>java.net.URI</code> to <code>xs:anyURI</code>. .NET's
                <code>DataContractSerializer</code> and
                <code>XmlSerializer</code> bind <code>xs:anyURI</code>
                differently:</para>

                <itemizedlist>
                    <listitem>
                        <para><code>DataContractSerializer</code> binds
                        <code>xs:anyURI</code> to .NET type
                        <code>System.Uri</code>.</para>
                    </listitem>

                    <listitem>
                        <para><code>XmlSerializer</code> binds
                        <code>xs:anyURI</code> to .NET type
                        <code>System.string</code>.</para>
                    </listitem>
                </itemizedlist>

                <para>Thus, the above technique only works if the WSDL is
                processed using <code>DataContractSerializer</code>.</para>

                <example>
                    <title><code>@XmlSchemaType</code> and
                    <code>DataContractSerializer</code></title>

                    <programlisting language="java" linenumbering="unnumbered">// Java code fragment
public class PurchaseOrder
{
    @XmlSchemaType(name="anyURI")
     public java.net.URI uri;
}

//-- Schema fragment
&lt;xs:complexType name="purchaseOrder"&gt;
    &lt;xs:sequence&gt;
        &lt;xs:element name="uri" type="xs:anyURI" minOccurs="0"/&gt;
    &lt;/xs:sequence&gt;
&lt;/xs:complexType&gt;

//--- .NET auto generated code from schema
//--- Using svcutil.exe /serializer:DataContractSerializer &lt;wsdl file&gt;
public partial class purchaseOrder : object,
        System.Runtime.Serialization.IExtensibleDataObject
{

    private System.Uri uriField;

    //-- ..... other generated code ........
    public System.Uri uri
    {
        get { return this.uriField; }
        set { this.uriField = value; }
    }
}

//--- C# code fragment
purchaseOrder tmpU = new purchaseOrder()
tmpU.uri = new System.Uri("../Hello", System.UriKind.Relative);</programlisting>
                </example>

                <example>
                    <title><code>@XmlSchemaType</code> and
                    <code>XmlSerializer</code></title>

                    <programlisting language="java" linenumbering="unnumbered">// Java code fragment
public class PurchaseOrder
{
    @XmlSchemaType(name="anyURI")
    public java.net.URI uri;
}

//--- .NET auto generated code from schema
//--- Using svcutil.exe /serializer:XmlSerializer &lt;wsdl file&gt;
public partial class purchaseOrder
{
    private string uriField;
    public string uri
    {
        get { return this.uriField; }
        set { this.uriField = value; }
    }
}

//--- C# code fragment
purchaseOrder tmpU = new purchaseOrder()
tmpU.uri = "mailto:mailto:mduerst@ifi.unizh.ch";</programlisting>
                </example>
            </section>

            <section xml:id="ahihd">
                <title>Duration</title>

                <para><emphasis>Guideline:</emphasis> Use .NET's
                <code>System.Xml.XmlConvert</code> to generate a lexical
                representation of <code>xs:duration</code> when the binding is
                to a type of <code>System.string</code>.</para>

                <para><code>javax.xml.datatype.Duration</code> maps to
                <code>xs:duration</code>. .NET maps <code>xs:duration</code>
                to a different datatype for
                <code>DataContractSerializer</code> and
                <code>XmlSerializer</code>.</para>

                <itemizedlist>
                    <listitem>
                        <para><code>DataContractSerializer</code> binds
                        <code>xs:duration</code> to .NET
                        <code>System.TimeSpan</code>.</para>
                    </listitem>

                    <listitem>
                        <para><code>XmlSerializer</code> binds
                        <code>xs:duration</code> to .NET
                        <code>System.string</code>.</para>
                    </listitem>
                </itemizedlist>

                <para>When <code>xs:duration</code> is bound to .NET
                <code>System.string</code>, the string value must be a lexical
                representation for <code>xs:duration</code>. .NET provides
                utility <code>System.Xml.XmlConvert</code> for this
                purpose.</para>

                <example>
                    <title>Mapping <code>xs:duration</code> using
                    <code>DataContactSerializer</code></title>

                    <programlisting language="java" linenumbering="unnumbered">//-- Java code fragment
public class PurchaseReport {
     public javax.xml.datatype.Duration period;
}

//-- Schema fragment
&lt;xs:complexType name="purchaseReport"&gt;
    &lt;xs:sequence&gt;
        &lt;xs:element name="period" type="xs:duration" minOccurs="0"/&gt;
    &lt;/xs:sequence&gt;
&lt;/xs:complexType&gt;

//-- .NET auto generated code from schema
//-- Using svcutil.exe /serializer:DataContractSerializer &lt;wsdl file&gt;
public partial class purchaseReport: object,
        System.Runtime.Serialization.IExtensibleDataObject
{
    private System.TimeSpan periodField;
    //-- ..... other generated code ........
    public System.TimeSpan period
    {
        get { return this.periodField; }
        set { this.periodField = value; }
    }
}

//-- C# code fragment
purchaseReport tmpR = new purchaseReport();
tmpR.period = new System.TimeSpan.MaxValue;</programlisting>
                </example>

                <example>
                    <title>Mapping <code>xs:duration</code> using
                    <code>XmlSerializer</code></title>

                    <programlisting language="java" linenumbering="unnumbered">//-- .NET auto generated code from schema
//-- Using svcutil.exe /serializer:XmlSerializer &lt;wsdl file&gt;
public partial class purchaseReport
{
    private string periodField;
    public string period
    {
        get { return this.periodField; }
        set { this.periodField = value; }
    }
}

//-- C# code fragment
purchaseReport tmpR = new purchaseReport();
tmpR.period = System.Xml.XmlConvert.ToString(new System.TimeSpan(23, 0,0));</programlisting>
                </example>
            </section>

            <section xml:id="ahihe">
                <title>Binary Types</title>

                <para><emphasis>Guideline:</emphasis>
                <code>java.awt.Image</code>,
                <code>javax.xml.transform.Source</code>, and
                <code>jakarta.activation.DataHandler</code> map to
                <code>xs:base64Binary</code>. .NET maps
                <code>xs:base64Binary</code> to <code>byte[]</code>.</para>

                <para>Jakarta XML Binding provides the annotation
                <code>@XmlMimeType</code>, which supports specifying the
                content type, but .NET ignores this information.</para>

                <example>
                    <title>Mapping <code>java.awt.Image</code>
                    <emphasis>without</emphasis>
                    <code>@XmlMimeType</code></title>

                    <programlisting language="java" linenumbering="unnumbered">//-- Java code fragment
public class Claim {
    public java.awt.Image photo;
}

//-- Schema fragment
&lt;xs:complexType name="claim"&gt;
    &lt;xs:sequence&gt;
        &lt;xs:element name="photo" type="xs:base64Binary" minOccurs="0"/&gt;
    &lt;/xs:sequence&gt;
&lt;/xs:complexType&gt;

//-- .NET auto generated code from schema
public partial class claim : object,
        System.Runtime.Serialization.IExtensibleDataObject
{
    private byte[] photoField;
    //-- ..... other generated code .......
    public byte[] photo
    {
        get { return this.photoField; }
        set { this.photoField = value; }
    }
}

//-- C# code fragment
try
{
    claim tmpC = new claim();

    System.IO.FileStream f = new System.IO.FileStream(
        "C:\\icons\\circleIcon.gif", System.IO.FileMode.Open);
    int cnt = (int)f.Length;
    tmpC.photo = new byte[cnt];
    int rCnt = f.Read(tmpC.photo, 0, cnt);

}
catch (Exception e)
{
    Console.WriteLine(e.ToString());
}</programlisting>
                </example>

                <example>
                    <title>Mapping <code>java.awt.Image</code>
                    <emphasis>with</emphasis>
                    <code>@XmlMimeType</code></title>

                    <programlisting language="java" linenumbering="unnumbered">//-- Java code fragment
public class Claim {
    @XmlMimeType("image/gif")
    public java.awt.Image photo;
}

//-- Schema fragment
&lt;xs:complexType name="claim"&gt;
    &lt;xs:sequence&gt;
        &lt;xs:element name="photo" ns1:expectedContentTypes="image/gif"
                    type="xs:base64Binary" minOccurs="0"
                    xmlns:ns1="http://www.w3.org/2005/05/xmlmime"/&gt;
    &lt;/xs:sequence&gt;
&lt;/xs:complexType&gt;

//-- Using the @XmlMimeType annotation doesn't change .NET
//--auto generated code
public partial class claim : object,
        System.Runtime.Serialization.IExtensibleDataObject
{
    private byte[] photoField;
    //-- ..... other generated code .......
    public byte[] photo
    {
        get { return this.photoField; }
        set { this.photoField = value; }
    }
}

//-- This code is unchanged by the different schema
//-- C# code fragment
try
{
    claim tmpC = new claim();

    System.IO.FileStream f = new System.IO.FileStream(
        "C:\\icons\\circleIcon.gif", System.IO.FileMode.Open);
    int cnt = (int)f.Length;
    tmpC.photo = new byte[cnt];
    int rCnt = f.Read(tmpC.photo, 0, cnt);
}
catch (Exception e)
{
    Console.WriteLine(e.ToString());
}</programlisting>
                </example>
            </section>

            <section xml:id="ahihf">
                <title>XMLGregorianCalendar Type</title>

                <para><emphasis>Guideline:</emphasis> Use
                <code>java.xml.datatype.XMLGregorianCalendar</code> instead of
                <code>java.util.Date</code> and
                <code>java.util.Calendar</code>.</para>

                <para><code>XMLGregorianCalendar</code> supports the following
                XML schema calendar types: <code>xs:date</code>,
                <code>xs:time</code>, <code>xs:dateTime</code>,
                <code>xs:gYearMonth</code>, <code>xs:gMonthDay</code>,
                <code>xs:gYear</code>, <code>xs:gMonth</code>, and
                <code>xs:gDay</code>. It is statically mapped to
                <code>xs:anySimpleType</code>, the common schema type from
                which all the XML schema calendar types are dervived. .NET
                maps <code>xs:anySimpleType</code> to
                <code>System.string</code>.</para>

                <para><code>java.util.Date</code> and
                <code>java.util.Calendar</code> map to
                <code>xs:dateTime</code>, but don't provide as complete
                XML support as <code>XMLGregorianCalendar</code> does.</para>

                <para><emphasis>Guideline:</emphasis> Use the annotation
                <code>@XmlSchemaType</code> for a strongly typed binding of
                <code>XMLGregorianCalendar</code> to one of the XML schema
                calendar types.</para>

                <example>
                    <title><code>XmlGregorianCalendar</code>
                    <emphasis>without</emphasis>
                    <code>@XmlSchemaType</code></title>

                    <programlisting language="java" linenumbering="unnumbered">//-- Java code fragment
public class PurchaseOrder {
    public javax.xml.datatype.XMLGregorianCalendar orderDate;
}

//-- Schema fragment
&lt;xs:complexType name="purchaseOrder"&gt;
    &lt;xs:sequence&gt;
        &lt;xs:element name="orderDate" type="xs:anySimpleType" minOccurs="0"/&gt;
    &lt;/xs:sequence&gt;
&lt;/xs:complexType&gt;

//-- .NET auto generated code from schema
public partial class purchaseOrder
{
    private string orderDateField;
    public string orderDate
    {
        get { return this.orderDateField; }
        set { this.orderDateField = value; }
    }
}

//-- C# code fragment
purchaseOrder tmpP = new purchaseOrder();
tmpP.orderDate = System.Xml.XmlConvert.ToString(
   System.DateTime.Now, System.Xml.XmlDateTimeSerializerMode.RoundtripKind);</programlisting>
                </example>

                <example>
                    <title><code>XMLGregorianCalendar</code>
                    <emphasis>with</emphasis>
                    <code>@XmlSchemaType</code></title>

                    <programlisting language="java" linenumbering="unnumbered">//-- Java code fragment
public class PurchaseOrder {
    @XmlSchemaType(name="dateTime")
    public javax.xml.datatype.XMLGregorianCalendar orderDate;
}

//-- Schema fragment
&lt;xs:complexType name="purchaseOrder"&gt;
    &lt;xs:sequence&gt;
        &lt;xs:element name="orderDate" type="xs:dateTime" minOccurs="0"/&gt;
    &lt;/xs:sequence&gt;
&lt;/xs:complexType&gt;

//-- .NET auto generated code from schema
public partial class purchaseOrder : object,
        System.Runtime.Serialization.IExtensibleDataObject
{
    private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
    private System.DateTime orderDateField;

    public System.Runtime.Serialization.ExtensionDataObject ExtensionData
    {
        get { return this.extensionDataField; }
        set { this.extensionDataField = value; }
    }

    public System.DateTime orderDate
    {
        get { return this.orderDateField; }
        set { this.orderDateField = value; }
    }
}

//-- C# code fragment
purchaseOrder tmpP = new purchaseOrder();
tmpP.orderDate = System.DateTime.Now;</programlisting>
                </example>
            </section>

            <section xml:id="ahihg">
                <title>UUID Type</title>

                <para><emphasis>Guideline:</emphasis> Use Leach-Salz variant
                of UUID at runtime.</para>

                <para><code>java.util.UUID</code> maps to schema type
                <code>xs:string</code>. .NET maps <code>xs:string</code> to
                <code>System.string</code>. The constructors in
                <code>java.util.UUID</code> allow any variant of UUID to be
                created. Its methods are for manipulation of the Leach-Salz
                variant.</para>

                <example>
                    <title>Mapping <code>UUID</code></title>

                    <programlisting language="java" linenumbering="unnumbered">//-- Java code fragment
public class ReportUid {
    public java.util.UUID uuid;
}

//-- Schema fragment
&lt;xs:complexType name="reportUid"&gt;
    &lt;xs:sequence&gt;
        &lt;xs:element name="uuid" type="xs:string" minOccurs="0"/&gt;
    &lt;/xs:sequence&gt;
&lt;/xs:complexType&gt;

//-- .NET auto generated code from schema
public partial class reportUid: object,
        System.Runtime.Serialization.IExtensibleDataObject
{
    private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
    private string uuidField;

    public System.Runtime.Serialization.ExtensionDataObject ExtensionData
    {
        get { return this.extensionDataField; }
        set { this.extensionDataField = value; }
    }

    public string uuid
    {
        get { return this.uuidField; }
        set { this.uuidField = value; }
    }
}

//-- C# code fragment
reportUid tmpU = new reportUid();
System.Guid guid = new System.Guid("06b7857a-05d8-4c14-b7fa-822e2aa6053f");
tmpU.uuid = guid.ToString();</programlisting>
                </example>
            </section>

            <section xml:id="ahihh">
                <title>Typed Variables</title>

                <para><emphasis>Guideline:</emphasis> A typed variable maps to
                <code>xs:anyType</code>. .NET maps <code>xs:anyType</code> to
                <code>System.Object</code>.</para>

                <example>
                    <title>Using a typed variable</title>

                    <programlisting language="java" linenumbering="unnumbered">// Java class
public class Shape &lt;T&gt;
{
    private T xshape;

    public Shape() {};
    public Shape(T f)
    {
        xshape = f;
    }
}

//-- Schema fragment
&lt;xs:complexType name="shape"&gt;
    &lt;xs:sequence&gt;
        &lt;xs:element name="xshape" type="xs:anyType" minOccurs="0"/&gt;
    &lt;/xs:sequence&gt;
&lt;/xs:complexType&gt;

// C# code generated by svcutil
public partial class shape
{
    private object xshapeField;

    public object xshape
    {
        get { return this.xshapeField; }
        set { this.xshapeField = value; }
    }
}</programlisting>
                </example>
            </section>

            <section xml:id="ahihi">
                <title>Collections Types</title>

                <para>Java collections types
                (<code>java.util.Collection</code> and its subtypes, array,
                List, and parameterized collection types such as
                <code>List&lt;Integer&gt;</code>) can be mapped to XML schema
                in different ways and can be serialized in different ways. The
                following examples show .NET bindings.</para>

                <section xml:id="ahihj">
                    <title>List of Nillable Elements</title>

                    <para><emphasis>Guideline:</emphasis> By default, a
                    collection type such as <code>List&lt;Integer&gt;</code>
                    maps to an XML schema construct that is a repeating
                    unbounded occurrence of an optional and nillable element.
                    .NET binds the XML schema construct to
                    <code>System.Nullable&lt;int&gt;[]</code>. The element is
                    optional and nillable. However, when marshalling Jakarta
                    XML Binding
                    marshaller will always marshal a null value using
                    <code>xsi:nil</code>.</para>

                    <example>
                        <title>Collection to a list of nillable
                        elements</title>

                        <programlisting language="java"
                                        linenumbering="unnumbered">//-- Java code fragment
@XmlRootElement(name="po")
public PurchaseOrder {
    public List&lt;Integer&gt; items;
}

//-- Schema fragment
&lt;xs:element name="po" type="purchaseOrder"&gt;
&lt;xs:complexType name="purchaseOrder"&gt;
    &lt;xs:sequence&gt;
        &lt;xs:element name="items" type="xs:int" nillable="true"
                    minOccurs="0" maxOccurs="unbounded"/&gt;
    &lt;/xs:sequence&gt;
&lt;/xs:complexType&gt;
...

//--- Jakarta XML Binding XML serialization
&lt;po&gt;
    &lt;items&gt; 1 &lt;/items&gt;
    &lt;items&gt; 2 &lt;/items&gt;
    &lt;items&gt; 3 &lt;/items&gt;
&lt;/po&gt;

&lt;po&gt;
    &lt;items&gt; 1 &lt;/items&gt;
    &lt;items xsi:nil=true/&gt;
    &lt;items&gt; 3 &lt;/items&gt;
&lt;/po&gt;

//-- .NET auto generated code from schema
partial class purchaseOrder {
        private System.Nullable&lt;int&gt;[] itemsField;

    public System.Nullable&lt;int&gt;[] items
    {
        get { return this.itemsField; }
        set { this.itemsField = value; }
    }
}</programlisting>
                    </example>
                </section>

                <section xml:id="ahihk">
                    <title>List of Optional Elements</title>

                    <para><emphasis>Guideline:</emphasis> This is the same as
                    above except that a collection type such as
                    <code>List&lt;Integer&gt;</code> maps to a repeating
                    unbounded occurrence of an optional
                    (<code>minOccurs="0"</code>) but not nillable element.
                    This in turn binds to .NET type <code>int[]</code>. This
                    is more developer friendly. However, when marshalling,
                    Jakarta XML Binding will marshal a null value within the
                    <code>List&lt;Integer&gt;</code> as a value that is absent
                    from the XML instance.</para>

                    <example>
                        <title>Collection to a list of optional
                        elements</title>

                        <programlisting language="java"
                                        linenumbering="unnumbered">//-- Java code fragment
@XmlRootElement(name="po")
public PurchaseOrder {
    @XmlElement(nillable=false)
    public List&lt;Integer&gt; items;
}

//-- Schema fragment
&lt;xs:element name="po" type="purchaseOrder"&gt;
&lt;xs:complexType name="purchaseOrder"&gt;
    &lt;xs:sequence&gt;
        &lt;xs:element name="items" type="xs:int"
                    minOccurs="0" maxOccurs="unbounded"/&gt;
    &lt;/xs:sequence&gt;
&lt;/xs:complexType&gt;
...

// .NET auto generated code from schema
partial class purchaseOrder {
    private int[] itemsField;

    public int[] items
    {
        get { return this.itemsField; }
        set { this.itemsField = value; }
    }
}</programlisting>
                    </example>
                </section>

                <section xml:id="ahihl">
                    <title>List of Values</title>

                    <para><emphasis>Guideline:</emphasis> A collection such as
                    <code>List&lt;Integer&gt;</code> can be mapped to a list
                    of XML values (that is, an XML schema list simple type)
                    using annotation <code>@XmlList</code>. .NET maps a list
                    simple type to a .NET <code>System.string</code>.</para>

                    <example>
                        <title>Collection to a list of values using
                        <code>@XmlList</code></title>

                        <programlisting language="java"
                                        linenumbering="unnumbered">//-- Java code fragment
@XmlRootElement(name="po")
public PurchaseOrder {
    @XmlList public List&lt;Integer&gt; items;
}

//-- Schema fragment
&lt;xs:element name="po" type="purchaseOrder"&gt;
&lt;xs:complexType name="purchaseOrder"&gt;
    &lt;xs:element name="items" minOccurs="0"&gt;
        &lt;xs:simpleType&gt;
            &lt;xs:list itemType="xs:int"/&gt;
        &lt;/xs:simpleType&gt;
    &lt;/xs:element&gt;
&lt;/xs:complexType&gt;
...

//-- XML serialization
&lt;po&gt;
    &lt;items&gt; 1 2 3 &lt;/items&gt;
&lt;/po&gt;

// .NET auto generated code from schema
partial class purchaseOrder {
    private string itemsField;

    public string items
    {
        get { return this.itemsField; }
        set { this.itemsField = value; }
    }
}</programlisting>
                    </example>
                </section>
            </section>

            <section xml:id="ahihm">
                <title>Array Types</title>

                <example>
                    <title>Single and multidimensional arrays</title>

                    <programlisting language="java" linenumbering="unnumbered">//-- Java code fragment
public class FamilyTree {
    public Person[] persons;
    public Person[][] family;
}

// .NET auto generated code from schema
public partial class familyTree
{
    private person[] persons;
    private person[][] families;

    public person[] persons
    {
        get { return this.membersField; }
        set { this.membersField = value; }
    }

    public person[][] families
    {
        get { return this.familiesField; }
        set { this.familiesField = value; }
    }
}</programlisting>
                </example>
            </section>
        </section>

        <section xml:id="ahihn">
            <title>Fields and Properties</title>

            <para>The following guidelines apply to mapping of JavaBeans
            properties and Java fields, but for brevity Java fields are
            used.</para>

            <section xml:id="ahiho">
                <title>@XmlElement Annotation</title>

                <para><emphasis>Guideline:</emphasis> The
                <code>@XmlElement</code> annotation maps a property or field
                to an XML element. This is also the default mapping in the
                absence of any other Jakarta XML Binding annotations. The annotation
                parameters in <code>@XmlElement</code> can be used to specify
                whether the element is optional or required, nillable or not.
                The following examples illustrate the corresponding bindings
                in the .NET client.</para>

                <example>
                    <title>Map a field or property to a nillable
                    element</title>

                    <programlisting language="java" linenumbering="unnumbered">//-- Java code fragment
public class PurchaseOrder {

    // Map a field to a nillable XML element
    @jakarta.xml.bind.annotation.XmlElement(nillable=true)
    public java.math.BigDecimal price;
}

//-- Schema fragment
&lt;xs:complexType name="purchaseOrder"&gt;
    &lt;xs:sequence&gt;
        &lt;xs:element name="price" type="xs:decimal"
                    nillable="true" minOccurs="0" /&gt;
    &lt;/xs:sequence&gt;
&lt;/xs:complexType&gt;

// .NET auto generated code from schema
public partial class purchaseOrder {
    private System.Nullable&lt;decimal&gt; priceField;
    private bool priceFieldSpecified;

    public decimal price
    {
        get { return this.priceField; }
        set { this.priceField = value; }
    }

    public bool priceSpecified {
    {
        get { return this.priceFieldSpecified; }
        set { this.priceFieldSpecified = value;}
    }
}</programlisting>
                </example>

                <example>
                    <title>Map a property or field to a nillable, required
                    element</title>

                    <programlisting language="java" linenumbering="unnumbered">//-- Java code fragment
public class PurchaseOrder {

    // Map a field to a nillable XML element
    @XmlElement(nillable=true, required=true)
    public java.math.BigDecimal price;
}

//-- Schema fragment
&lt;xs:complexType name="purchaseOrder"&gt;
    &lt;xs:sequence&gt;
        &lt;xs:element name="price" type="xs:decimal"
                    nillable="true" minOccurs="1" /&gt;
    &lt;/xs:sequence&gt;
&lt;/xs:complexType&gt;

// .NET auto generated code from schema
public partial class purchaseOrder {
    private System.Nullable&lt;decimal&gt; priceField;

    public decimal price
    {
        get { return this.priceField; }
        set { this.priceField = value; }
    }
}</programlisting>
                </example>
            </section>

            <section xml:id="ahihp">
                <title>@XmlAttribute Annotation</title>

                <para><emphasis>Guideline:</emphasis> A property or field can
                be mapped to an XML attribute using <code>@XmlAttribute</code>
                annotation. .NET binds an XML attribute to a property.</para>

                <example>
                    <title>Mapping a field or property to an XML
                    attribute</title>

                    <programlisting language="java" linenumbering="unnumbered">//-- Java code fragment
public class UKAddress extends Address {
    @XmlAttribute
    public int exportCode;
}

//-- Schema fragment
&lt;! XML Schema fragment --&gt;
&lt;xs:complexType name="ukAddress"&gt;
    &lt;xs:complexContent&gt;
        &lt;xs:extension base="tns:address"&gt;
            &lt;xs:sequence/&gt;
            &lt;xs:attribute name="exportCode" type="xs:int"/&gt;
        &lt;/xs:extension&gt;
    &lt;/xs:complexContent&gt;
&lt;/xs:complexType&gt;

// .NET auto generated code from schema
public partial class ukAddress : address
{
    private int exportCodeField;
    public int exportCode
    {
        get { return this.exportCodeField; }
        set { this.exportCodeField = value; }
    }
}</programlisting>
                </example>
            </section>

            <section xml:id="ahihq">
                <title>@XmlElementRefs Annotation</title>

                <para><emphasis>Guideline:</emphasis>
                <code>@XmlElementRefs</code> maps to a <code>xs:choice</code>.
                This binds to a property with name <code>item</code> in the C#
                class. If there is another field/property named
                <code>item</code> in the Java class, there will be a name
                clash that .NET will resolve by generating name. To avoid the
                name clash, either change the name or use customization, for
                example <code>@XmlElement(name="foo")</code>.</para>

                <example>
                    <title>Mapping a field or property using
                    <code>@XmlElementRefs</code></title>

                    <programlisting language="java" linenumbering="unnumbered">//-- Java code fragment
public class PurchaseOrder {
    @XmlElementRefs({
        @XmlElementRef(name="plane", type=PlaneType.class),
        @XmlElementRef(name="auto", type=AutoType.class)})
    public TransportType shipBy;
}

@XmlRootElement(name="plane")
public class PlaneType extends TransportType {}

@XmlRootElement(name="auto")
public class AutoType extends TransportType { }

@XmlRootElement
public class TransportType { ... }

//-- Schema fragment
&lt;!-- XML schema generated by wsgen --&gt;
&lt;xs:complexType name="purchaseOrder"&gt;
    &lt;xs:choice&gt;
        &lt;xs:element ref="plane"/&gt;
        &lt;xs:element ref="auto"/&gt;
    &lt;/xs:choice&gt;
&lt;/xs:complexType&gt;

&lt;!-- XML global elements --&gt;
&lt;xs:element name="plane" type="autoType" /&gt;
&lt;xs:element name="auto" type="planeType" /&gt;

&lt;xs:complexType name="autoType"&gt;
    &lt;!-- content omitted - details not relevant to example --&gt;
&lt;/xs:complexType&gt;

&lt;/xs:complexType name="planeType"&gt;
    &lt;!-- content omitted - details not relevant to example --&gt;
&lt;/xs:complexType&gt;

// .NET auto generated code from schema
public partial class purchaseOrder {
    private transportType itemField;

    [System.Xml.Serialization.XmlElementAttribute("auto", typeof(autoType), Order=4)]
    [System.Xml.Serialization.XmlElementAttribute("plane", typeof(planeType), Order=4)]
    public transportType Item
    {
        get { return this.itemField; }
        set { this.itemField = value; }
    }

public partial class planeType { ... } ;
public partial class autoType { ... } ;</programlisting>
                </example>
            </section>
        </section>

        <section xml:id="ahihr">
            <title>Java Classes</title>

            <para>A Java class can be mapped to different XML schema type
            and/or an XML element. The following guidelines apply to the usage
            of annotations at the class level.</para>

            <section xml:id="ahihs">
                <title>@XmlType Annotation - Anonymous Type</title>

                <para><emphasis>Guideline:</emphasis> Prefer mapping class to
                named XML schema type rather than an anonymous type for a
                better .NET type binding.</para>

                <para>The <code>@XmlType</code> annotation is used to
                customize the mapping of a Java class to an anonymous type.
                .NET binds an anonymous type to a .NET class - one per
                reference to the anonymous type. Thus, each Java class mapped
                to an anonymous type can generate multiple classes on the .NET
                client.</para>

                <example>
                    <title>Mapping a Java class to an anonymous type using
                    <code>@XmlType</code></title>

                    <programlisting language="java" linenumbering="unnumbered">//-- Java code fragment
public class PurchaseOrder {
    public java.util.List&lt;Item&gt; item;
}
@XmlType(name="")
public class Item {
    public String productName;
    ...
}

//-- Schema fragment
&lt;xs:complexType name="purchaseOrder"&gt;
    &lt;xs:sequence&gt;
        &lt;xs:element name="item"&gt;
            &lt;xs:complexType&gt;
                &lt;xs:sequence&gt;
                    &lt;xs:element name="productName" type="xs:string"/&gt;
                &lt;/xs:sequence&gt;
            &lt;/xs:complexType
&gt;        &lt;/xs:element&gt;
    &lt;/xs:sequence&gt;
&lt;/xs:complexType&gt;

// C# code generated by svcutil
public partial class purchaseOrder
{
    private purchaseOrderItem[] itemField;
    System.Xml.Serialization.XmlElementAttribute("item",
        Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true, Order=0)]
    public purchaseOrderItem[] item
    {
        get {
            return this.itemField;
        }

        set {
            this.itemField = value;
        }
    }
}

// .NET auto generated code from schema
public partial class purchaseOrderItem
{
    private string productNameField;
    public string productName {
        get { return this.productNameField; }
        set { this.productNameField = value; }
    }
}</programlisting>
                </example>
            </section>

            <section xml:id="ahiht">
                <title>@XmlType Annotation - xs:all</title>

                <para><emphasis>Guideline:</emphasis> Avoid using
                <code>XmlType(propOrder=:{})</code>.</para>

                <para><code>@XmlType(propOrder={})</code> maps a Java class to
                an XML Schema complex type with <code>xs:all</code> content
                model. Since XML Schema places severe restrictions on
                <code>xs:all</code>, the use of
                <code>@XmlType(propOrder={})</code> is therefore not
                recommended. So, the following example shows the mapping of a
                Java class to <code>xs:all</code>, but the corresponding .NET
                code generated by <code>svcutil</code> is omitted.</para>

                <example>
                    <title>Mapping a class to <code>xs:all</code> using
                    <code>@XmlType</code></title>

                    <programlisting language="java" linenumbering="unnumbered">//-- Java code fragment
@XmlType(propOrder={})
public class USAddress {
    public String name;
    public String street;
}

//-- Schema fragment
&lt;xs:complexType name="USAddress"&gt;
    &lt;xs:all&gt;
        &lt;xs:element name="name" type="xs:string"/&gt;
        &lt;xs:element name="street" type="xs:string"/&gt;
        ...
    &lt;/xs:all&gt;
&lt;/xs:complexType&gt;</programlisting>
                </example>
            </section>

            <section xml:id="ahihu">
                <title>@XmlType Annotation - Simple Content</title>

                <para><emphasis>Guideline:</emphasis> A class can be mapped to
                a <code>complexType</code> with a <code>simpleContent</code>
                using <code>@XmlValue</code> annotation. .NET binds the Java
                property annotated with <code>@XmlValue</code> to a property
                with name <code>"value"</code>.</para>

                <example>
                    <title>Class to <code>complexType</code> with
                    <code>simpleContent</code></title>

                    <programlisting language="java" linenumbering="unnumbered">//-- Java code fragment
public class InternationalPrice
{
    @XmlValue
    public java.math.BigDecimal price;

    @XmlAttribute public String currency;
}

//-- Schema fragment
&lt;xs:complexType name="internationalPrice"&gt;
    &lt;xs:simpleContent&gt;
        &lt;xs:extension base="xs:decimal"&gt;
            xs:attribute name="currency" type="xs:string"/&gt;
        &lt;/xs:extension&gt;
    &lt;/xs:simpleContent&gt;
 &lt;/xs:complexType&gt;

// .NET auto generated code from schema
public partial class internationalPrice
{
    private string currencyField;
    private decimal valueField;
    public string currency
    {
        get { return this.currencyField; }
        set { this.currencyField = value;}
    }

    public decimal Value
    {
        get { return this.valueField; }
        set { this.valueField = value;}
    }
}</programlisting>
                </example>
            </section>
        </section>

        <section xml:id="ahihv">
            <title>Open Content</title>

            <para>Jakarta XML Binding supports the following annotations for defining
            open content. (Open content allows content not statically defined
            in XML schema to occur in an XML instance):</para>

            <itemizedlist>
                <listitem>
                    <para>The <code>@XmlAnyElement</code> annotation maps to
                    <code>xs:any</code>, which binds to the .NET type
                    <code>System.Xml.XmlElement[]</code>.</para>
                </listitem>

                <listitem>
                    <para>The <code>@XmlAnyAttribute</code> annotation maps to
                    <code>xs:anyAttribute</code>, which binds to the .NET type
                    <code>System.Xml.XmlAttribute[]</code>.</para>
                </listitem>
            </itemizedlist>

            <example>
                <title>Using <code>@XmlAnyElement</code> for open
                content</title>

                <programlisting language="java" linenumbering="unnumbered">//-- Java code fragment
@XmlType(propOrder={"name", "age", "oc"})
public class OcPerson {
    @XmlElement(required=true)
    public String name;
    public int age;

    // Define open content
    @XmlAnyElement
    public List&lt;Object&gt; oc;
}

//-- Schema fragment
&lt;xs:complexType name="ocPerson"&gt;
    &lt;xs:sequence&gt;
        &lt;xs:element name="name" type="xs:string"/&gt;
        &lt;xs:element name="age" type="xs:int"/&gt;
        &lt;xs:any minOccurs="0" maxOccurs="unbounded"&gt;
    &lt;/xs:sequence&gt;
&lt;/xs:complexType&gt;

// .NET auto generated code from schema
public class ocPerson
{
    private String name;
    private int age;
    private System.Xml.XmlElement[] anyField;&lt;

    public String name { ... }
    public int age { ... }

    public System.Xml.XmlElement[] Any {
    {
        get { return this.anyField; }
        set { this.anyField = value; }
    }
}</programlisting>
            </example>

            <example>
                <title>Using <code>@XmlAnyAttribute</code> for open
                content</title>

                <programlisting language="java" linenumbering="unnumbered">//-- Java code fragment
@XmlType(propOrder={"name", "age"}
public class OcPerson {
    public String name;
    public int age;

    // Define open content
    @XmlAnyAttribute
    public java.util.Map oc;
}

//-- Schema fragment
&lt;xs:complexType name="ocPerson"&gt;
    &lt;xs:sequence&gt;
        &lt;xs:element name="name" type="xs:string"/&gt;
        &lt;xs:element name="age" type="xs:int"/&gt;
    &lt;/xs:sequence&gt;
    &lt;xs:anyAttribute/&gt;
&lt;/xs:complexType&gt;

// .NET auto generated code from schema
public class ocPerson
{
    private String name;
    private double age;
    private System.Xml.XmlAttribute[] anyAttrField;&lt;

    public String name { ... }
    public double age { ... }

    public System.Xml.XmlElement[] anyAttr {
    {
        get { return this.anyAttrField; }
        set { this.anyAttrField = value; }
    }
}</programlisting>
            </example>
        </section>

        <section xml:id="ahihw">
            <title>Enum Type</title>

            <para><emphasis>Guideline:</emphasis> A Java <code>enum</code>
            type maps to an XML schema type constrained by enumeration facets.
            This, in turn, binds to the .NET type <code>enum</code>
            type.</para>

            <example>
                <title>Java <code>enum</code> ↔ <code>xs:simpleType</code>
                (with <code>enum</code> facets) ↔ .NET
                <code>enum</code></title>

                <programlisting language="java" linenumbering="unnumbered">//-- Java code fragment
public enum USState {MA, NH}

//-- Schema fragment
&lt;xs:simpleType name="usState"&gt;
    &lt;xs:restriction base="xs:string"&gt;
        &lt;xs:enumeration value="NH" /&gt;
        &lt;xs:enumeration value="MA" /&gt;
    &lt;/xs:restriction&gt;
&lt;/xs:simpleType&gt;

// .NET auto generated code from schema
public enum usState { NH, MA }</programlisting>
            </example>
        </section>

        <section xml:id="ahihx">
            <title>Package-level Annotations</title>

            <para>The following package-level Jakarta XML Binding annotations are relevant
            from an interoperability standpoint:</para>

            <itemizedlist>
                <listitem>
                    <para><code>@XmlSchema</code> - customizes the mapping of
                    package to XML namespace.</para>
                </listitem>

                <listitem>
                    <para><code>@XmlSchemaType</code> - customizes the mapping
                    of XML schema built-in type. The
                    <code>@XmlSchemaType</code> annotation can also be used at
                    the property/field level, as was seen in the example <xref
                    linkend="ahihf" xrefstyle="select:title" />.</para>
                </listitem>
            </itemizedlist>

            <section xml:id="ahihy">
                <title>@XmlSchema Annotation</title>

                <para>A package is mapped to an XML namespace. The following
                attributes of the XML namespace can be customized using the
                <code>@XmlSchema</code> annotation parameters:</para>

                <itemizedlist>
                    <listitem>
                        <para><code>elementFormDefault</code> using
                        <code>@XmlSchema.elementFormDefault()</code></para>
                    </listitem>

                    <listitem>
                        <para><code>attributeFormDefault</code> using
                        <code>@XmlSchema.attributeFormDefault()</code></para>
                    </listitem>

                    <listitem>
                        <para><code>targetNamespace</code> using
                        <code>@XmlSchema.namespace()</code></para>
                    </listitem>

                    <listitem>
                        <para>Associate namespace prefixes with the XML
                        namespaces using the <code>@XmlSchema.ns()</code>
                        annotation</para>
                    </listitem>
                </itemizedlist>

                <para>These XML namespace attributes are bound to .NET
                serialization attributes (for example,
                <code>XmlSerializer</code> attributes).</para>
            </section>

            <section xml:id="ahihz">
                <title>Not Recommended Annotations</title>

                <para>Any Jakarta XML Binding annotation can be used, but the following
                are not recommended:</para>

                <itemizedlist>
                    <listitem>
                        <para>The
                        <code>jakarta.xml.bind.annotation.XmlElementDecl</code>
                        annotation is used to provide complete XML schema
                        support.</para>
                    </listitem>

                    <listitem>
                        <para>The <code>@XmlID</code> and
                        <code>@XmlIDREF</code> annotations are used for XML
                        object graph serialization, which is not well
                        supported.</para>
                    </listitem>
                </itemizedlist>
            </section>
        </section>
    </section>

    <section xml:id="ahiia">
        <title>Web Service - Start from WSDL</title>

        <para>The following guidelines apply when designing a Java web service
        starting from a WSDL:</para>

        <orderedlist>
            <listitem>
                <para>If the WSDL was generated by
                <code>DataContractSerializer</code>, enable Jakarta XML Binding
                customizations described in <xref linkend="ahiic"
                xrefstyle="select:title" />. The rationale for the Jakarta XML Binding
                customizations is described in the same section.</para>
            </listitem>

            <listitem>
                <para>If the WSDL is a result of contract first approach,
                verify that the WSDL can be processed by either the
                <code>DataContractSerializer</code> or
                <code>XmlSerializer</code> mechanisms.</para>

                <para>The purpose of this step is to ensure that the WSDL uses
                only the set of XML schema features supported by Jakarta XML Binding or
                .NET serialization mechanisms. Jakarta XML Binding was designed to
                support all the XML schema features. The WCF serialization
                mechanisms, <code>DataContractSerializer</code> and
                <code>XmlSerializer</code>, provide different levels of
                support for XML schema features. Thus, the following step will
                ensure that the WSDL/schema file can be consumed by the WCF
                serialization mechanisms.</para>

                <programlisting><emphasis role="bold">svcutil <emphasis>wsdl-file</emphasis></emphasis></programlisting>

                <para>The <code>svcutil.exe</code> tool, by default, uses
                <code>DataContractSerializer</code> but falls back to
                <code>XmlSerializer</code> if it encounters an XML schema
                construct not supported by <code>XmlFormatter</code>.</para>
            </listitem>
        </orderedlist>
    </section>

    <section xml:id="ahiic">
        <title>Customizations for WCF Service WSDL</title>

        <para>When developing either a Java web service or a Java client from
        a WCF service WSDL generated using
        <code>DataContractSerializer</code>, the following Jakarta XML Binding 2.0
        customizations are useful and/or required.</para>

        <itemizedlist>
            <listitem>
                <para><code>generateElementProperty</code> attribute</para>
            </listitem>

            <listitem>
                <para><code>mapSimpleTypeDef</code> attribute</para>
            </listitem>
        </itemizedlist>

        <para>The following sections explain the use and rationale of these
        customizations.</para>

        <section xml:id="ahiid">
            <title>generateElementProperty Attribute</title>

            <para>WCF service WSDL generated from a programming language such
            as C# using <code>DataContractSerializer</code> may contain XML
            Schema constructs which result in
            <code>JAXBElement&lt;T&gt;</code> in generated code. A
            <code>JAXBElement&lt;T&gt;</code> type can also sometimes be
            generated when a WSDL contains advanced XML schema features such
            as substitution groups or elements that are both optional and
            nillable. In all such cases, <code>JAXBElement&lt;T&gt;</code>
            provides roundtripping support of values in XML instances.
            However, <code>JAXBElement&lt;T&gt;</code> is not natural to a
            Java developer. So the <code>generateElementProperty</code>
            customization can be used to generate an alternate developer
            friendly but lossy binding. The different bindings along with the
            trade-offs are discussed below.</para>

            <section xml:id="ahiie">
                <title>Default Binding</title>

                <para>The following is the default binding of an optional
                <code>(minOccurs="0")</code> and
                <code>nillable(nillable="true")</code> element:</para>

                <example>
                    <programlisting language="xml" linenumbering="unnumbered">&lt;!-- XML schema fragment --&gt;
&lt;xs:element name="person" type="Person"/&gt;
&lt;xs:complexType name="Person"&gt;
    &lt;xs:sequence&gt;
        &lt;xs:element name="name" type="xs:string"
                    nillable="true" minOccurs="0"/&gt;
    &lt;/xs:sequence&gt;
&lt;/xs:complexType&gt;
...</programlisting>
                </example>

                <example>
                    <programlisting language="java" linenumbering="unnumbered">// Binding
public class Person {
    JAXBElement&lt;String&gt; getName() {...};
    public void setName(JAXBElement&lt;String&gt; value) {...}
}</programlisting>
                </example>

                <para>Since the XML element <code>name</code> is both optional
                and nillable, it can be represented in an XML instance in one
                of following ways:</para>

                <example>
                    <programlisting language="xml" linenumbering="unnumbered">&lt;!-- Absence of element name--&gt;
&lt;person&gt;
    &lt;-- element name is absent --&gt;
&lt;/person&gt;

&lt;!-- Presence of an element name --&gt;
&lt;person&gt;
    &lt;name xsi:nil="true"/&gt;
&lt;/person&gt;</programlisting>
                </example>

                <para>The <code>JAXBElement&lt;String&gt;</code> type
                roundtrips the XML representation of <code>name</code> element
                across an unmarshal/marshal operation.</para>
            </section>

            <section xml:id="ahiif">
                <title>Customized Binding</title>

                <para>When <code>generateElementProperty</code> is false, the
                binding is changed as follows:</para>

                <example>
                    <programlisting language="java" linenumbering="unnumbered">// set Jakarta XML Binding customization generateElementProperty="false"
public class Person {
    String getName() {...}
    public void setName(String value) {...}
}</programlisting>
                </example>

                <para>The above binding is more natural to Java developer than
                <code>JAXBElement&lt;String&gt;</code>. However, it does not
                roundtrip the value of <code>name</code>.</para>

                <para>Jakarta XML Binding allows <code>generateElementProperty</code> to
                be set:</para>

                <itemizedlist>
                    <listitem>
                        <para>Globally in
                        <code>&lt;jaxb:globalBindings&gt;</code></para>
                    </listitem>

                    <listitem>
                        <para>Locally in <code>&lt;jaxb:property&gt;</code>
                        customization</para>
                    </listitem>
                </itemizedlist>

                <para>When processing a WCF service WSDL, it is recommended
                that the <code>generateElementProperty</code> customization be
                set in <code>&lt;jaxb:globalBindings&gt;</code>:</para>

                <example>
                    <programlisting language="xml" linenumbering="unnumbered">&lt;jaxb:bindings version="2.0"
               xmlns:jxb="http://java.sun.com/xml/ns/jaxb"
               xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
    &lt;jaxb:bindings schemaLocation="schema-importedby-wcfsvcwsdl"
                   node="/xs:schema"&gt;
        &lt;jaxb:globalBindings generateElementProperty="false"/&gt;
    &lt;/jaxb:bindings&gt;
    ...</programlisting>
                </example>

                <note>
                    <para>The <code>generateElementProperty</code> attribute
                    was introduced in Jakarta XML Binding 2.1.</para>
                </note>
            </section>

            <section xml:id="ahiig">
                <title>mapSimpleTypeDef Attribute</title>

                <para>XML Schema Part 2: Datatype defines facilities for
                defining datatypes for use in XML Schemas. .NET platform
                introduced the CLR types for some of the XML schema datatypes
                as described in <xref linkend="ahiih"
                xrefstyle="select:title" />.</para>

                <table frame="all" xml:id="ahiih">
                    <title>CLR to XML Schema Type Mapping</title>

                    <tgroup cols="2" colsep="1" rowsep="1">
                        <thead>
                            <row>
                                <entry><para>CLR Type</para></entry>

                                <entry><para>XML Schema Type</para></entry>
                            </row>
                        </thead>

                        <tbody>
                            <row>
                                <entry><para> <code>byte</code> </para></entry>

                                <entry><para> <code>xs:unsignedByte</code>
                                </para></entry>
                            </row>

                            <row>
                                <entry><para> <code>uint</code> </para></entry>

                                <entry><para> <code>xs:unsignedInt</code>
                                </para></entry>
                            </row>

                            <row>
                                <entry><para> <code>ushort</code> </para></entry>

                                <entry><para> <code>xs:unsignedShor</code>
                                </para></entry>
                            </row>

                            <row>
                                <entry><para> <code>ulong</code> </para></entry>

                                <entry><para> <code>xs:unsignedLong</code>
                                </para></entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>

                <para>However, there are no corresponding Java types that map
                to the XML Schema types listed in <xref linkend="ahiih"
                xrefstyle="select:title" />. Furthermore, Jakarta XML Binding maps these
                XML schema types to Java types that are natural to Java
                developer. However, this results in a mapping that is not
                one-to-one. For example:</para>

                <itemizedlist>
                    <listitem>
                        <para><code>xs:int -&gt; int</code></para>
                    </listitem>

                    <listitem>
                        <para><code>xs:unsignedShort -&gt; int</code></para>
                    </listitem>
                </itemizedlist>

                <para>The lack of a one-to-one mapping means that when XML
                Schema types shown in <xref linkend="ahiih"
                xrefstyle="select:title" /> are used in an
                <code>xsi:type</code> construct, they won't be preserved
                by default across an unmarshal followed by marshal operation.
                For example:</para>

                <example>
                    <programlisting language="java" linenumbering="unnumbered">// C# web method
public Object retObject(Object objvalue);
// Java web method generated from WCF service WSDL
public Object retObject(
    Object objvalue);
}</programlisting>
                </example>

                <para>The following illustrates why <code>xsi:type</code> is
                not preserved across an unmarshal/marshal operation.</para>

                <itemizedlist>
                    <listitem>
                        <para>A value of type <code>uint</code> is marshalled
                        by WCF serialization mechanism as:</para>

                        <example>
                            <programlisting language="xml">&lt;objvalue xsi:type="xs:unsignedShort"/&gt;</programlisting>
                        </example>
                    </listitem>

                    <listitem>
                        <para>Jakarta XML Binding unmarshaller unmarshals the value as an
                        instance of <code>int</code> and assigns it to
                        parameter <code>objvalue</code>.</para>
                    </listitem>

                    <listitem>
                        <para>The <code>objvalue</code> is marshalled back by
                        Jakarta XML Binding marshaller with an <code>xsi:type</code> of
                        <code>xs:int</code>.</para>

                        <example>
                            <programlisting language="xml">&lt;objvalue xsi:type="xs:int"/&gt;</programlisting>
                        </example>
                    </listitem>
                </itemizedlist>

                <para>One way to preserve and roundtrip the
                <code>xsi:type</code> is to use the
                <code>mapSimpleTypeDef</code> customization. The customization
                makes the mapping of XML Schema Part 2 datatypes one--to-one
                by generating additional Java classes. Thus,
                <code>xs:unsignedShort</code> will be bound to its own class
                rather than <code>int</code>, as shown:</para>

                <example>
                    <programlisting language="java" linenumbering="unnumbered">//Java class to which xs:unsignedShort is bound
public class UnsignedShort { ... }</programlisting>
                </example>

                <para>The following illustrates how the <code>xsi:type</code>
                is preserved across an unmarshal/marshal operation:</para>

                <itemizedlist>
                    <listitem>
                        <para>A value of type <code>uint</code> is marshalled
                        by WCF serialization mechanism as:</para>

                        <example>
                            <programlisting language="xml">&lt;objvalue xsi:type="xs:unsignedShort"/&gt;</programlisting>
                        </example>
                    </listitem>

                    <listitem>
                        <para>Jakarta XML Binding unmarshaller unmarshals the value as an
                        instance of <code>UnsignedShort</code> and assigns it
                        to parameter <code>objvalue</code>.</para>
                    </listitem>

                    <listitem>
                        <para>The <code>objvalue</code> is marshalled back by
                        Jakarta XML Binding marshaller with an <code>xsi:type</code> of
                        <code>xs:int</code>.</para>

                        <example>
                            <programlisting language="xml">&lt;objvalue xsi:type="xs:unsignedShort"/&gt;</programlisting>
                        </example>
                    </listitem>
                </itemizedlist>

                <para><emphasis>Guideline:</emphasis> Use the
                <code>mapSimpleTypedef</code> customization where
                roundtripping of XML Schema types in <xref linkend="ahiih"
                xrefstyle="select:title" /> are used in <code>xsi:type</code>.
                However, it is preferable to avoid the use of CLR types listed
                in <xref linkend="ahiih" xrefstyle="select:title" /> since
                they are specific to .NET platform.</para>

                <para>The syntax of the <code>mapSimpleTypeDef</code>
                customization is shown below.</para>

                <example>
                    <programlisting language="xml" linenumbering="unnumbered">&lt;jaxb:bindings version="2.0"
               xmlns:jxb="http://java.sun.com/xml/ns/jaxb"
               xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
    &lt;jaxb:bindings schemaLocation="schema-importedby-wcfsvcwsdl"&gt;
        &lt;jaxb:globalBindings mapSimpleTypeDef="true"/&gt;
    &lt;/jaxb:bindings&gt;
    ....</programlisting>
                </example>
            </section>
        </section>
    </section>

    <section xml:id="ahiii">
        <title>Developing a Microsoft .NET Client</title>

        <para>This section describes how to develop a .NET client that uses
        data binding.</para>

        <task xml:id="gfrep">
            <title>To Develop a Microsoft .NET Client</title>

            <tasksummary>
                <para>Perform the following steps to generate a Microsoft .NET
                client from a Java web service WSDL file.</para>
            </tasksummary>

            <procedure>
                <step>
                    <para><emphasis role="bold">Generate WCF web service
                    client artifacts using the <code>svcutil.exe</code>
                    tool:</emphasis></para>

                    <programlisting><emphasis role="bold">svcutil.exe <emphasis>java-web-service-wsdl</emphasis></emphasis></programlisting>

                    <para><code>svcutil.exe</code> has the following options
                    for selecting a serializer:</para>

                    <stepalternatives>
                        <step>
                            <para><code>svcutil.exe /serializer:auto</code>
                            (default)</para>
                        </step>

                        <step>
                            <para><code>svcutil.exe
                            /serializer:DataContractSerializer</code></para>
                        </step>

                        <step>
                            <para><code>svcutil.exe
                            /serializer:XmlSerializer</code></para>
                        </step>
                    </stepalternatives>

                    <para>It is recommended that you use the default option,
                    <code>/serializer:auto</code>. This option ensures that
                    <code>svcutil.exe</code> falls back to
                    <code>XmlSerializer</code> if an XML schema construct is
                    used that cannot be processed by
                    <code>DataContractSerializer</code>.</para>

                    <para>For example, in the following class the field
                    <code>price</code> is mapped to an XML attribute that
                    cannot be consumed by
                    <code>DataContractSerializer</code>.</para>

                    <example>
                        <programlisting language="java"
                                        linenumbering="unnumbered">public class POType {
    @jakarta.xml.bind.annotation.XmlAttribute
    public java.math.BigDecimal price;
}

&lt;!-- XML schema fragment --&gt;
&lt;xs:complexType name="poType"&gt;
    &lt;xs:sequence/&gt;
    &lt;xs:attribute name="price" type="xs:decimal"/&gt;
&lt;/xs:complexType&gt;</programlisting>
                    </example>
                </step>

                <step>
                    <para><emphasis role="bold">Develop the .NET client using
                    the generated artifacts.</emphasis></para>
                </step>
            </procedure>
        </task>
    </section>

    <section xml:id="ahiij">
        <title>BP 1.1 Conformance</title>

        <para>Jakarta XML Web Services enforces strict Basic Profile 1.1 compliance. In one
        situation, the .NET framework does not enforce strict BP 1.1
        semantics, and their usage can lead to interoperability
        problems.</para>

        <para>In <code>rpclit</code> mode, <link
        xlink:href="http://www.ws-i.org/Profiles/BasicProfile-1.1-2006-04-10.html">BP
        1.1</link>, R2211 disallows the use of <code>xsi:nil</code> in part
        accessors: An <emphasis>ENVELOPE</emphasis> described with an
        <code>rpc-literal</code> binding <emphasis>MUST NOT</emphasis> have
        the <code>xsi:nil</code> attribute with a value of <code>"1"</code> or
        <code>"true"</code> on the part accessors.</para>

        <para>From a developer perspective this means that in
        <code>rpclit</code> mode, Jakarta XML Web Services does not allow a null to be passed in
        a web service method parameter.</para>

        <example>
            <programlisting language="java" linenumbering="unnumbered">//Java Web method
public byte[] retByteArray(byte[] inByteArray) {
    return inByteArray;
}</programlisting>
        </example>

        <example>
            <programlisting language="xml" linenumbering="unnumbered">&lt;!-- In rpclit mode, the above Java web service method will throw an exception
  if the following XML instance with xsi:nil is passed by a .NET client.--&gt;
  &lt;RetByteArray xmlns="http://tempuri.org/"&gt;
      &lt;inByteArray a:nil="true" xmlns=""
          xmlns:a="http://www.w3.org/2001/XMLSchema-instance"/&gt;
  &lt;/RetByteArray&gt;</programlisting>
        </example>
    </section>
</chapter>
